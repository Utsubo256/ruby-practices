#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'etc'

COLUMN = 3

def main
  params = options
  resources = target_resources
  sorted_resources = sort_resources(resources)
  if params[:l]
    formatted_resources = format_resources_for_l(sorted_resources)
    display_resources_for_l(formatted_resources)
  else
    formatted_resources = format_resources(sorted_resources)
    display_resources(formatted_resources)
  end
end

def options
  opt = OptionParser.new
  params = {}
  opt.on('-l') { |v| params[:l] = v }
  opt.parse!(ARGV)
  params
end

def target_resources
  resources = Dir.children('.')
  resources.reject { |file| file.start_with?('.') }
end

def sort_resources(resources)
  resources.sort_by { |resource| resource.downcase.gsub(/[.\-_]/, '') }
end

def format_resources(resources)
  column_number = (resources.size + COLUMN - 1) / COLUMN
  exit if column_number.zero?
  sliced_resources = resources.each_slice(column_number).to_a
  alligned_resources = sliced_resources.map do |names|
    names.map { |name| name.ljust(names.map(&:size).max + 2) }
  end
  (column_number - alligned_resources[-1].size).times { alligned_resources[-1] << nil }
  alligned_resources.transpose
end

def format_resources_for_l(resources)
  formatted_resources = []
  files = target_files(resources)
  max_nlink = files.map { |file| file[:nlink] }.max.to_s.size
  max_user = files.map { |file| file[:user] }.map(&:size).max
  max_group = files.map { |file| file[:group] }.map(&:size).max
  max_file_size = files.map { |file| file[:file_size] }.max.to_s.size
  files.map do |file|
    file[:nlink] = file[:nlink].to_s.rjust(max_nlink, ' ')
    file[:user] = file[:user].ljust(max_user, ' ')
    file[:group] = file[:group].ljust(max_group, ' ')
    file[:file_size] = file[:file_size].to_s.rjust(max_file_size, ' ')
    formatted_resources << file
  end
  formatted_resources
end

def target_files(resources)
  files = []
  resources.each do |resource|
    files << target_file_info(resource)
  end
  files
end

def target_file_info(resource)
  file_stat = File.new(File.absolute_path(resource)).stat
  blksize = file_stat.blocks / 2 # OS側では1ブロックサイズ1024bytes, Ruby側では512bytesで計算されるため補正
  file_type = target_file_type(file_stat.ftype)
  permission = target_permission(file_stat.mode)
  file_permission = file_type + permission
  nlink = file_stat.nlink
  user = Etc.getpwuid(file_stat.uid).name
  group = Etc.getgrgid(file_stat.gid).name
  file_size = file_stat.size
  mtime = file_stat.mtime.strftime('%b %e %R')
  { blksize:, file_permission:, nlink:, user:, group:, file_size:, mtime:, resource: }
end

def target_file_type(ftype)
  {
    'file' => '-',
    'directory' => 'd',
    'characterSpecial' => 'c',
    'blockSpecial' => 'b',
    'fifo' => 'p',
    'link' => 'l',
    'socket' => 's'
  }[ftype]
end

def target_permission(mode)
  binary = mode.to_s(2)[-9..]
  permission_attributes = []
  binary.chars.each_slice(3) do |attributes|
    permission_attributes << (attributes[0] == '1' ? 'r' : '-')
    permission_attributes << (attributes[1] == '1' ? 'w' : '-')
    permission_attributes << (attributes[2] == '1' ? 'x' : '-')
  end
  permission_attributes.join
end

def display_resources(resources)
  resources.each do |column|
    puts column.compact.join
  end
end

def display_resources_for_l(resources)
  total_blksize = resources.map { |resource| resource[:blksize] }.sum
  resources.map { |resource| resource.delete(:blksize) }
  puts "total #{total_blksize}"
  resources.each do |resource|
    puts resource.values.join(' ')
  end
end

main
